@page "/main-canvas"
@using Class
@using Class.Services
@using Microsoft.JSInterop
@implements IAsyncDisposable

<canvas id="myCanvas" width="600px" height="400px" style="border: 1px solid black;" @ref="canvasReference"
></canvas>

@code {
    private ElementReference canvasReference;
    private DotNetObjectReference<MainCanvas>? dotNetHelper;
    private IJSObjectReference? _canvasContext;
    private bool isDragging = false;
    private ITable? selectedRect = null;
    private double offsetX, offsetY;
    private List<ITable>? rectangles;

    [Inject]
    public IJSRuntime? JS { get; set; }

    protected override async Task OnInitializedAsync()
    {
        rectangles = new List<ITable>
        {
            new RectangleTable(1,"S001",0,0,100,100,"unlocked"),
            new CircleTable(2,"S002", 150, 150, 50, "unlocked")
        };
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && JS != null)
        {

            dotNetHelper = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("canvasInterop.initialize", canvasReference, dotNetHelper);
            _canvasContext = await JS.InvokeAsync<IJSObjectReference>("canvasInterop.getContext2D", canvasReference);
            await JS.InvokeVoidAsync("dragDropInterop.initializeDropzone", "myCanvas", dotNetHelper);
            await DrawRectanglesAsync();
        }
    }

    private async Task DrawRectanglesAsync()
    {
        if(rectangles != null && JS != null && _canvasContext != null)
        {
            await JS.InvokeVoidAsync("canvasInterop.clearCanvas", canvasReference, _canvasContext);

            foreach (var rect in rectangles)
            {
                await rect.Draw(JS, _canvasContext);
            }
        }
    }

    [JSInvokable]
    public async Task OnMouseDown(double clientX, double clientY)
    {
        var rect = await GetBoundingClientRectAsync(canvasReference);
        var x = clientX - rect.Left;
        var y = clientY - rect.Top;

        if (rectangles != null)
        {
            foreach (var rectangle in rectangles)
            {
                if (rectangle.IsMouseInRange(x,y))
                {
                    isDragging = true;
                    selectedRect = rectangle;
                    offsetX = x - rectangle.X;
                    offsetY = y - rectangle.Y;
                    break;
                }
            }
        }
    }

    [JSInvokable]
    public async Task OnMouseMove(double clientX, double clientY)
    {
        if (isDragging)
        {
            var rect = await GetBoundingClientRectAsync(canvasReference);
            var x = clientX - rect.Left - offsetX;
            var y = clientY - rect.Top - offsetY;
            if (selectedRect != null)
            {
                double canvasWidth = 600;
                double canvasHeight = 400;
                ITable tempShape = selectedRect.Clone();
                tempShape.X = x;
                tempShape.Y = y;
                if (!CollisionUtils.IsCollidingWithBorderX(tempShape, canvasWidth))
                {
                    selectedRect.X = x;
                }
                if (!CollisionUtils.IsCollidingWithBorderY(tempShape, canvasHeight))
                {
                    selectedRect.Y = y;
                }
            }
            await DrawRectanglesAsync();
        }

    }

    [JSInvokable]
    public void OnMouseUp()
    {
        isDragging = false;
        selectedRect = null;
    }

    private async Task<DOMRect> GetBoundingClientRectAsync(ElementReference element)
    {
        if(JS != null)
        {
            return await JS.InvokeAsync<DOMRect>("canvasInterop.getBoundingClientRect", element);
        }
        else
        {
            throw new Exception("JSRuntime is null");
        }
    }

    [JSInvokable] 
    public async Task HandleDropTableData(Shape data, double clientX, double clientY) { 
        if (data != null) { 
            Console.WriteLine($"Dropped data: {data.ToString()}");

            var rect = await GetBoundingClientRectAsync(canvasReference);
            var x = clientX - rect.Left;
            var y = clientY - rect.Top;

            if (rectangles != null)
            {
                if(data.ShapeType == "rectangle")
                {
                    x -= data.Width / 2;
                    y -= data.Height / 2;
                    rectangles.Add(
                    new RectangleTable(rectangles.Count + 1, data.ShapeId, x, y, data.Width, data.Height, "unlocked")
                    );
                }
                else if (data.ShapeType == "circle")
                {
                    rectangles.Add(
                        new CircleTable(rectangles.Count + 1, data.ShapeId, x, y, data.Radius, "unlocked")
                    );
                }
            }

            await DrawRectanglesAsync();


        } 
    }

    public async ValueTask DisposeAsync() { 

    }

    public class dndData
    {
        public string data { get; set; }
        public string type { get; set; }

        public dndData(string data, string type)
        {
            this.type = type;
            this.data = data;
        }
    }

    private class DOMRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Right { get; set; }
        public double Bottom { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }

    private class Rect
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }
}
