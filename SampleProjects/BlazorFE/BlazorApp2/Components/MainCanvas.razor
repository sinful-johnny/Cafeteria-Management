@page "/main-canvas"
@using Class
@using Class.Services
@using Microsoft.JSInterop
@using System.Linq
@inject FoodListItemService foodListItemService;
@implements IAsyncDisposable

<canvas id="myCanvas" width="600px" height="400px" style="border: 1px solid black;" @ref="canvasReference"
></canvas>

@code {
    private ElementReference canvasReference;
    private DotNetObjectReference<MainCanvas>? dotNetHelper;
    private IJSObjectReference? _canvasContext;
    private bool isDragging = false;
    private ITable? selectedRect = null;
    private double offsetX, offsetY;
    private List<ITable>? rectangles;

    [Inject]
    public IJSRuntime? JS { get; set; }

    protected override async Task OnInitializedAsync()
    {
        rectangles = new List<ITable>
        {
            new RectangleTable(1,"S001",0,0,100,100,"unlocked"),
            new CircleTable(2,"S002", 150, 150, 50, "unlocked")
        };
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && JS != null)
        {

            dotNetHelper = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("canvasInterop.initialize", canvasReference, dotNetHelper);
            _canvasContext = await JS.InvokeAsync<IJSObjectReference>("canvasInterop.getContext2D", canvasReference);
            await JS.InvokeVoidAsync("dragDropInterop.initializeDropzone", "myCanvas", dotNetHelper);
            await DrawRectanglesAsync();
        }
    }

    private async Task DrawRectanglesAsync()
    {
        if(rectangles != null && JS != null && _canvasContext != null)
        {
            await JS.InvokeVoidAsync("canvasInterop.clearCanvas", canvasReference, _canvasContext);

            foreach (var rect in rectangles)
            {
                await rect.Draw(JS, _canvasContext);
            }
        }
    }

    [JSInvokable]
    public async Task OnMouseDown(double clientX, double clientY)
    {
        var rect = await GetBoundingClientRectAsync(canvasReference);
        var x = clientX - rect.Left;
        var y = clientY - rect.Top;

        if (rectangles != null)
        {
            foreach (var rectangle in rectangles)
            {
                if (rectangle.IsMouseInRange(x,y))
                {
                    isDragging = true;
                    selectedRect = rectangle;
                    offsetX = x - rectangle.X;
                    offsetY = y - rectangle.Y;

                    // foreach(var food in rectangle.Foods)
                    // {
                    //     Console.WriteLine(food.ToString());
                    // }

                    break;
                }
            }
        }
    }

    [JSInvokable]
    public async Task OnMouseMove(double clientX, double clientY)
    {
        if (isDragging)
        {
            var rect = await GetBoundingClientRectAsync(canvasReference);
            var x = clientX - rect.Left - offsetX;
            var y = clientY - rect.Top - offsetY;
            if (selectedRect != null)
            {
                double canvasWidth = 600;
                double canvasHeight = 400;
                ITable tempShape = selectedRect.Clone();
                tempShape.X = x;
                tempShape.Y = y;
                if (!CollisionUtils.IsCollidingWithBorderX(tempShape, canvasWidth))
                {
                    selectedRect.X = x;
                }
                if (!CollisionUtils.IsCollidingWithBorderY(tempShape, canvasHeight))
                {
                    selectedRect.Y = y;
                }
            }
            await DrawRectanglesAsync();
        }

    }

    [JSInvokable]
    public void OnMouseUp()
    {
        isDragging = false;
        selectedRect = null;
    }

    private async Task<DOMRect> GetBoundingClientRectAsync(ElementReference element)
    {
        if(JS != null)
        {
            return await JS.InvokeAsync<DOMRect>("canvasInterop.getBoundingClientRect", element);
        }
        else
        {
            throw new Exception("JSRuntime is null");
        }
    }

    [JSInvokable] 
    public async Task HandleDropTableData(Shape data, double clientX, double clientY) { 
        if (data != null) { 
            Console.WriteLine($"Dropped data: {data.ToString()}");

            var rect = await GetBoundingClientRectAsync(canvasReference);
            var x = clientX - rect.Left;
            var y = clientY - rect.Top;

            if (rectangles != null)
            {
                if(data.ShapeType == "rectangle")
                {
                    x -= data.Width / 2;
                    y -= data.Height / 2;
                    rectangles.Add(
                    new RectangleTable(rectangles.Count + 1, data.ShapeId, x, y, data.Width, data.Height, "unlocked")
                    );
                }
                else if (data.ShapeType == "circle")
                {
                    rectangles.Add(
                        new CircleTable(rectangles.Count + 1, data.ShapeId, x, y, data.Radius, "unlocked")
                    );
                }
            }

            await DrawRectanglesAsync();
        } 
    }

    [JSInvokable]
    public async Task HandleDropFoodData(dndFoodData data, double clientX, double clientY)
    {
        if (data != null)
        {
            //Console.WriteLine($"Dropped data: {data.ToString()}");

            var rect = await GetBoundingClientRectAsync(canvasReference);
            var x = clientX - rect.Left;
            var y = clientY - rect.Top;

            if (rectangles != null)
            {
                foreach (var rectangle in rectangles)
                {
                    if (rectangle.IsMouseInRange(x, y))
                    {
                        Food? foodInfo = null;
                        foreach(var foodList in foodListItemService.Items)
                        {
                            if(foodList.Content != null)
                            {
                                foreach (var food in foodList.Content)
                                {
                                    if(food.FoodId == data.FoodId)
                                    {
                                        foodInfo = food;
                                        break;
                                    }
                                }
                            }

                        }

                        if(foodInfo != null)
                        {
                            var findFoodResult = rectangle.Foods.FirstOrDefault<FoodOnTable>(x => x.Food.FoodId == foodInfo.FoodId);
                            if(findFoodResult != null)
                            {
                                findFoodResult.Amount += 1;
                            }
                            else
                            {
                                rectangle.Foods.Add(new FoodOnTable(foodInfo,1));
                                rectangle.Color = "red";
                            }
                            await DrawRectanglesAsync();
                        }
                        break;
                    }
                }
            }
        }
    }

    public async ValueTask DisposeAsync() { 

    }

    public class dndFoodData
    {
        public int FoodId { get; set; }
        public string type { get; set; }

        public dndFoodData(int FoodId, string type)
        {
            this.type = type;
            this.FoodId = FoodId;
        }
    }

    private class DOMRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Right { get; set; }
        public double Bottom { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }

    private class Rect
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }
}
